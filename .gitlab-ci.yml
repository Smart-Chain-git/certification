#
# GITLAB - CI
#

# We use a gradle image to run all stages of the pipeline.
# Each stage runs a bare (not wrapped) `gradle ...` command.
image: $REGISTRY_PUBLIC_URL/gradle:6.3-jdk11

# The pipeline consists of several stages. Each one is run in parallel.
stages:
  - test # runs all the tests of the application.
  - build
  - publish

# Sets the environement variables before executing scripts.
variables:
  # timezone for TU that use date
  TZ: "Europe/Paris"
  # Disable daemon for Gradle
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"

# Before each stage's script.
before_script:
  - echo `pwd` # debug
  - echo "$CI_BUILD_NAME, $CI_BUILD_REF_NAME $CI_BUILD_STAGE" # debug
  - export GRADLE_USER_HOME=`pwd`/.gradle

# There use to be a `cache` key here. We removed it because it was actually
# slower than downloading again the resources.
# All gradle dependencies are fetched from the Nexus. It was slower to unzip the
# cache before the stage and zip it back after the stage.
cache:
  key: tezosservers

#
# Stage: test
#

test unit:
  stage: test
  # We tell gitlab-ci to use a machine running the docker-runner from gitlab.
  # Here, we need the script to be run in a docker image (using the gradle image defined above).
  tags:
    - docker
  # We can use the bare gradle command here because of the gradle docker image.
  # We use the `continue` option to display each test failure in the console instead of only the first one.
  script:
    - gradle test --continue
  # We create an artifact to be passed to the next stage.
  # Artifact contain the backend related compiled classes and ressources.
  artifacts:
    expire_in: 5 hrs
    when: always
    paths:
      - "*/build"
      - "*/*/build"

#
# Stage: build
#

build:
  stage: build
  tags:
    - docker
  script:
    - gradle assemble
  artifacts:
    expire_in: 5 hrs
    when: always
    paths:
      - "*/build"
      - "*/*/build"

#
# Stage: publish
#

sonar:
  stage: publish
  dependencies:
    - build
  tags:
    - docker
  # The (free) version of Sonar we use doesnt verify the branch on which the analysis is done.
  # Because, there can be WIP on developement branches, is would destroy the graphs. Hence we run
  # the sonar analysis only on master branch and release tags.
  only:
    refs:
      - master
      - tags
  script:
    # Build and upload the result of sonarqube analysis.
    # http://sonarqube.sonar.10.20.2.179.xip.io/dashboard?id=com.kami%3Aoutside
    - gradle check jacocoRootReport sonarqube
# Publish the JAR to the nexus
publishJar:
  stage: publish
  dependencies:
    - build
  tags:
    - docker
  only:
    refs:
      - master
      - tags
  script:
    - gradle publish -PmavenProxyUrl=$MAVEN_PROXY_URL -PnexusUrl=$NEXUS_URL -PnexusUser=$NEXUS_USER -PnexusPassword=$NEXUS_PASSWORD -PreleasesRepo=$RELEASES_REPO -PsnapshotsRepo=$SNAPSHOTS_REPO
# Build a docker image for the web app and push it to the registry.
publishDockerUi:
  stage: publish
  dependencies:
    - build
  tags:
    - dockerBuild
  script:
    # Create the unpacked folder.
    - mkdir frontend/ui/build/unpacked
    # Unpack the jar for light docker image.
    - (cd frontend/ui/build/unpacked; jar -xf ../libs/*.jar)
    # Build the docker image tagged either with git branch name or tag.
    - docker build -t $REGISTRY_URL/sword/signature-web:$CI_COMMIT_REF_NAME frontend/ui
    # Push the image to the registry.
    - docker push $REGISTRY_URL/sword/signature-web:$CI_COMMIT_REF_NAME

publishDockerRSocket:
  stage: publish
  dependencies:
    - build
  tags:
    - dockerBuild
  script:
    # Create the unpacked folder.
    - mkdir frontend/rsocket/build/unpacked
    # Unpack the jar for light docker image.
    - (cd frontend/rsocket/build/unpacked; jar -xf ../libs/*.jar)
    # Build the docker image tagged either with git branch name or tag.
    - docker build -t $REGISTRY_URL/sword/signature-rsocket:$CI_COMMIT_REF_NAME frontend/rsocket
    # Push the image to the registry.
    - docker push $REGISTRY_URL/sword/signature-rsocket:$CI_COMMIT_REF_NAME

publishDockerRest:
  stage: publish
  dependencies:
    - build
  tags:
    - dockerBuild
  script:
    # Create the unpacked folder.
    - mkdir frontend/rest/build/unpacked
    # Unpack the jar for light docker image.
    - (cd frontend/rest/build/unpacked; jar -xf ../libs/*.jar)
    # Build the docker image tagged either with git branch name or tag.
    - docker build -t $REGISTRY_URL/sword/signature-rest:$CI_COMMIT_REF_NAME frontend/rest
    # Push the image to the registry.
    - docker push $REGISTRY_URL/sword/signature-rest:$CI_COMMIT_REF_NAME

publishDockerDaemon:
  stage: publish
  dependencies:
    - build
  tags:
    - dockerBuild
  script:
    # Create the unpacked folder.
    - mkdir backend/daemon/build/unpacked
    # Unpack the jar for light docker image.
    - (cd backend/daemon/build/unpacked; jar -xf ../libs/*.jar)
    # Build the docker image tagged either with git branch name or tag.
    - docker build -t $REGISTRY_URL/sword/signature-daemon:$CI_COMMIT_REF_NAME backend/daemon
    # Push the image to the registry.
    - docker push $REGISTRY_URL/sword/signature-daemon:$CI_COMMIT_REF_NAME